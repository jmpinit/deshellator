<!DOCTYPE html>
<html lang="en">
  <head>
    <title>deshellator</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body>
    <h1>Deshellator Renderer</h1>

    <video id="video" width=320 height=240 autoplay="true" style="display:none;"></video><br>

    <canvas id="tracking" width=320 height=240></canvas><br>
    <input id="offset-x" type="range" min="0" max="12" value="0" step="1" /><br>
    <input id="offset-y" type="range" min="0" max="64" value="0" step="1" /><br>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="js/three.min.js"></script>
    <script type="text/javascript" src="js/svd.js"></script> 
    <script type="text/javascript" src="js/posit1.js"></script> 
    <script type="text/javascript" src="js/cv.js"></script> 
    <script type="text/javascript" src="js/aruco.js"></script>

    <script id="fragmentShader" type="x-shader/x-fragment">
		uniform float time;
		uniform vec2 resolution;
        uniform sampler2D texture1;

        varying vec2 texCoord;

        void main(void) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            //gl_FragColor = texture2D(texture1, texCoord);
        }
	</script>
	<script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 texCoord;

        void main() {
            //texCoord = uv;

            gl_Position =   projectionMatrix *
                            modelViewMatrix *
                            vec4(position, 1.0);
        }
	</script>
    <script>
        var renderer, mesh, scene, camera;
        var calcCanvas;
        var calcImage = new Uint8ClampedArray(96 * 64 / 8);
        var offset = { x: 0, y: 0 };
        var rotationHistory = [];
        var rotationHistorySize = 10;

        $("#offset-x").change(function() {
            offset.x = parseInt($(this).val());
        });
        $("#offset-y").change(function() {
            offset.y = parseInt($(this).val());
        });

        var video = document.getElementById("video");
        var modelSize = 35.0; //millimeters

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        navigator.getUserMedia({ video:true },
            function (stream) {
                if (window.URL) {
                    video.src = window.webkitURL.createObjectURL(stream);
                } else if (video.mozSrcObject !== undefined) {
                    video.mozSrcObject = stream;
                } else {
                    video.src = stream;
                }
            },
            function(error){ }
        );

        var detector = new AR.Detector();
        var posit = new POS.Posit(modelSize, 320);
        var trackingCanvas = $('#tracking')[0];

        init();

        function init() {
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 100;

            scene = new THREE.Scene();
            var loader = new THREE.JSONLoader();

            loader.load("models/owen3d.json", function(geometry, materials) {
                var material = new THREE.ShaderMaterial({
                	uniforms: {
                		time: { type: "f", value: 1.0 },
                		resolution: { type: "v2", value: new THREE.Vector2() }//,
                        //texture1: { type: "t", value: materials[0].map }
                	},
                	vertexShader: document.getElementById('vertexShader').textContent,
                	fragmentShader: document.getElementById('fragmentShader').textContent
                });

                mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(100, 100, 100);
                mesh.position.x = 0;
                mesh.position.y = 0;
                mesh.position.z = 100;

                scene.add(mesh);

                animate();
            });

            var ambientLight = new THREE.AmbientLight(0x555555);
            scene.add(ambientLight);

            var directionalLight = new THREE.DirectionalLight(0xffffff);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(94, 64);

            document.body.appendChild(renderer.domElement);

            // create canvas for calculator image
            calcCanvas = document.createElement('canvas');
            calcCanvas.width = 96;
            calcCanvas.height = 64;
            calcCanvas.style.width = '640px';
            calcCanvas.style.width = '480px';
            document.body.appendChild(calcCanvas);
        }

        function animate() {
            // track
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                var context = trackingCanvas.getContext('2d');
                context.drawImage(video, 0, 0, trackingCanvas.width, trackingCanvas.height);
                imageData = context.getImageData(0, 0, trackingCanvas.width, trackingCanvas.height);
                var markers = detector.detect(imageData);

                if (markers.length > 0) {
                    //camera.lookAt(new THREE.Vector3(m.corners[0].x, m.corners[0].y, 0));

                    corners = markers[0].corners;

                    for (i = 0; i < corners.length; ++ i){
                        corner = corners[i];

                        corner.x = corner.x - (trackingCanvas.width / 2);
                        corner.y = (trackingCanvas.height / 2) - corner.y;
                    }

                    pose = posit.pose(corners);

                    //console.log(pose);
                    var t = pose.bestTranslation;
                    //camera.projectionMatrix.setPosition(new THREE.Vector3(t[0], t[1], t[2]));

                    var rotation = pose.bestRotation;
                    var rx = Math.asin(-rotation[1][2]);
                    var ry = -Math.atan2(rotation[0][2], rotation[2][2]);
                    var rz = Math.atan2(rotation[1][0], rotation[1][1]);
                    //camera.projectionMatrix.makeRotationFromEuler(new THREE.Euler(rx, ry, rz, "XYZ"));

                    var rotationHistorySize = 3;
                    var avgRotation = { x: 0, y: 0, z: 0 };

                    if (rotationHistory.length < rotationHistorySize) {
                        rotationHistory.push({ x: rx, y: ry, z: rz });
                    } else {
                        // shift
                        for (var i = rotationHistory.length-1; i > 0; i--) {
                            rotationHistory[i] = rotationHistory[i-1];
                        }
                        rotationHistory[0] = { x: rx, y: ry, z: rz };

                        // average
                        for (var i in rotationHistory) {
                            var r = rotationHistory[i];
                            avgRotation.x += r.x;
                            avgRotation.y += r.y;
                            avgRotation.z += r.z;
                        }

                        avgRotation.x /= rotationHistory.length;
                        avgRotation.y /= rotationHistory.length;
                        avgRotation.z /= rotationHistory.length;
                    }

                    /*mesh.position.x = t[0];
                    mesh.position.y = -t[1];
                    mesh.position.z = 1200-t[2];*/
                    /*mesh.rotation.x = rx;
                    mesh.rotation.y = ry;
                    mesh.rotation.z = rz;*/
                    
                    camera.position.x = -t[0];
                    camera.position.y = t[1];
                    camera.position.z = t[2];

                    var lookVector = new THREE.Vector3(0, 0, -1);
                    lookVector.applyEuler(new THREE.Euler(avgRotation.x, avgRotation.y, avgRotation.z, "XYZ"));
                    lookVector.add(camera.position);
                    //camera.up = new THREE.Vector3(0, 0, 1);
                    camera.lookAt(lookVector);
                } else {
                    //camera.lookAt(new THREE.Vector3(0, 0, 0));
                }
            }

            // render
            requestAnimationFrame(animate);
            renderer.render(scene, camera);

            // extract rendered image

            var w = calcCanvas.width;
            var h = calcCanvas.height;

            var renderedPixels = new Uint8Array(4 * w * h);

            var gl = renderer.getContext();
            gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, renderedPixels);

            var renderedImage = new ImageData(new Uint8ClampedArray(renderedPixels), w, h);
            var ditheredImage = new ImageData(new Uint8ClampedArray(4 * w * h), w, h);
            // dither onto second canvas

            var bayerMatrix = [
                [1, 9, 3, 11],
                [13, 5, 15, 7],
                [4, 12, 2, 10],
                [16, 8, 14, 6],
            ]

            var maxIndex = 4 * calcCanvas.width * calcCanvas.height - 1;

            for (var y = 0; y < calcCanvas.height; y++) {
                for (var x = 0; x < calcCanvas.width; x++) {
                    var isrc = (y * calcCanvas.width + x) * 4;
                    var idest = ((calcCanvas.height - 1 - y) * calcCanvas.width + x) * 4;

                    var brightness = (renderedPixels[isrc] +
                        renderedPixels[isrc + 1] +
                        renderedPixels[isrc + 2]) / 3.0;

                    var limit = 255.0 * bayerMatrix[y % 4][x % 4] / 17.0;

                    if (brightness < limit) {
                        ditheredImage.data[idest] = 0;
                        ditheredImage.data[idest + 1] = 0;
                        ditheredImage.data[idest + 2] = 0;
                    } else {
                        ditheredImage.data[idest] = 255;
                        ditheredImage.data[idest + 1] = 255;
                        ditheredImage.data[idest + 2] = 255;
                    }

                    // alpha
                    ditheredImage.data[idest + 3] = 255;
                }
            }

            var context = calcCanvas.getContext('2d');
            context.putImageData(ditheredImage, 0, 0);

            var w = 12;
            var h = 64;
            var outIndex = 0;
            var frameOffsetX = offset.x;
            var frameOffsetY = offset.y;

            for (var y = 0; y < h; y++) {
                for (var x = 0; x < w; x++) {
                    var sampleX = (x + frameOffsetX) % w;
                    var sampleY = (y + frameOffsetY) % h;

                    var sampleIndex = sampleY * w + sampleX;
                    var byte = 0;

                    for (var bit = 0; bit < 8; bit++) {
                        if (ditheredImage.data[(sampleIndex * 8 + bit) * 4] > 0) {
                            byte |= 0x80 >> bit;
                        }
                    }

                    calcImage[outIndex++] = byte;
                }
            }
        }

        var socket = new WebSocket('ws://localhost:4000', 'calc-protocol');

        var fps = 15;

        function calcLoop() {
            if (socket.readyState == WebSocket.OPEN) {
                socket.send(calcImage);
            }

            setTimeout(function() { calcLoop(); }, 1000 / fps);
        }

        calcLoop();
    </script>
  </body>
</html>
